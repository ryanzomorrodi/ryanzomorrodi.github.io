[
  {
    "objectID": "notes/ojs/index.html",
    "href": "notes/ojs/index.html",
    "title": "Observable JS for an ggplot2 user",
    "section": "",
    "text": "Over the past year I have been playing around with quarto and trying to learn more about some of its features. I have really been enjoying the fact that quarto allows me to chain my R and python scripts into one single reproducable document. But why should I stop there?\nThe following are my notes about using objective js to make data visualization as some one who primarily uses ggplot2."
  },
  {
    "objectID": "notes/ojs/index.html#ggplot2",
    "href": "notes/ojs/index.html#ggplot2",
    "title": "Observable JS for an ggplot2 user",
    "section": "ggplot2",
    "text": "ggplot2\nggplot2 was built with an underlying grammar, the Grammar of Graphics. This breaks down visualizations into 7 parts.\n\nData (ggplot()) - should be self-explanatory\nMapping (aes()) - Defines relationship between data and aesthetic attributes of layers\nLayers (geom_* or stat_*) - specifies graphical components displayed in a visualization\nScales (scale_*_*) - sets the axes, legends, and sometimes transformations\nFacets (facet_*) - splits up data into separate panels\nCoordinates (coord_*) - determines the coordinate system used to display elements\nThemes (theme*()) - control the look and feel of the plot elements\nNote: these are one line summaries of a much better description within the ggplot vignette, Introduction to ggplot2\nWhile this makes ggplot2 relatively easy to learn, but not all graphics libraries rely on this exact grammar. I will; however, try as best I can to translate the javascipt libraries used throughout these notes to this underlying grammar."
  },
  {
    "objectID": "notes/ojs/index.html#translating-to-plot.js",
    "href": "notes/ojs/index.html#translating-to-plot.js",
    "title": "Observable JS for an ggplot2 user",
    "section": "Translating to Plot.js",
    "text": "Translating to Plot.js\nI know you want to become the next NYT visualization guru, but first let’s try to make some simplish, but powerful plots with Plot.js. Plot.js is build on d3, which is the visualization library that your favorite NYT data viz wizards use. Its syntax is quite a lot easier to translate into ggplot methods as compared to d3 so this is where we will start.\nSince, we are focused on data viz. I’m going to get my data from R and send it over to javascript using ojs_define().\n\n\n\nR\n\nojs_define(iris = iris)\n\n\nWe can now access our data in ojs.\n\n\n\nojs\n\niris\n\n\n\n\n\n\n\n\nBasic scatterplot\nLet’s start ploting, but stick with R for a second. Let’s make a classic scatterplot. Notice we specify three elements of the grammar of graphics and assume the rest.\n\nRPlot.js\n\n\nData: iris\nMapping: aes(x = Petal.Length, y = Petal.Width)\nLayer: geom_point()\n\n\n\nR\n\nlibrary(ggplot2)\n\nggplot(iris, aes(x = Petal.Length, y = Petal.Width)) +\n    geom_point()\n\n\n\n\n\n\n\n\n\n\n\nData: transpose(iris)\nMapping: {x: Petal.Length, y: Petal.Width}\nLayer: Plot.dot()\n\n\n\nojs\n\nPlot.plot({\n  marks: [\n    Plot.dot(transpose(iris), {x: \"Petal.Length\", y: \"Petal.Width\"})\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\nBasic barplot\nThis is where we experience our first sort of problem. ggplot2 layers often calculate stats for us. In this case ggplot2 calculates a count of each of the species and maps that to the y of each bar. Plot.js will not do this. We need to first calculate our stat and specify it as our y. (imagine you were only able to use geom_col()).\n\nRPlot.js\n\n\nData: iris\nMapping: aes(x = Species, fill = Species)\nLayer: geom_bar()\n\n\n\nR\n\nggplot(iris, aes(x = Species, fill = Species)) +\n    geom_bar()\n\n\n\n\n\n\n\n\n\n\n\nFirst, we will calculate the count for each species and pass it to javascript. We could do this in javascript really easy with Arquero, which was inspired by dplyr, but we’re learning Plot.js right now, so stay focused.\nData: transpose(iris)\nMapping: {x: \"Species\", y: \"n\", fill: \"Species\"}\nLayer: Plot.barY()\n\n\n\nR\n\niris_freq &lt;- dplyr::count(iris, Species)\nojs_define(iris_freq = iris_freq)\n\n\n\n\n\nojs\n\nPlot.plot({\n  marks: [\n    Plot.barY(transpose(iris_freq), {x: \"Species\", y: \"n\", fill: \"Species\"})\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\nTemporal log-scale line plot\nNow we’re going to add a scale element to our specification.\n\nRPlot.js\n\n\nData: economics\nMapping: aes(x = date, y = unemploy)\nLayer: geom_bar()\nScale: scale_x_date() and scale_y_log10()\n\n\n\nR\n\nggplot(economics, aes(x = date, y = unemploy)) +\n    geom_line() + \n    scale_x_date() +\n    scale_y_log10()\n\n\n\n\n\n\n\n\n\n\n\nData: transpose(economics)\nMapping: {x: \"date\", y: \"unemploy\"}\nLayer: Plot.line()\nScale: x: {type: \"time} and y: {type: \"log\"}\n\n\n\nR\n\nojs_define(economics = economics)\n\n\n\n\n\nojs\n\nPlot.plot({\n  x: {type: \"time\"},\n  y: {type: \"log\"},\n  marks: [\n    Plot.line(transpose(economics), {x: \"date\", y: \"unemploy\"})\n  ]}\n)\n\n\n\n\n\n\n\n\n\n\n\n\nFaceted boxplot\nThis is one kind of plot that in ggplot2 is technically speaking faceted, but without the use of a facet_*() function, either way it still demonstrates the point.\n\nRPlot.js\n\n\nSomething is a weird about the y-axis here, but we’ll ignore it\nData: iris_round\nMapping: aes(x = Petal.Length)\nLayer: geom_boxplot()\nFacet: aes(group = round(Petal.Width / 0.4) * 0.4)\n\n\n\nR\n\nggplot(iris, aes(x = Petal.Length, group = Petal.Width)) +\n    geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n\nData: transpose(iris)\nMapping: {x: \"Petal.Length\"}\nLayer: Plot.boxX()\nFacet: transpose(iris).filter((d) =&gt; d[\"Petal.Length\"]) and {fy: \"Petal.Width\"}\n\n\n\nojs\n\nPlot.plot({\n  fy: {\n    reverse: true\n  },\n  marks: [\n    Plot.boxX(transpose(iris).filter((d) =&gt; d[\"Petal.Length\"]), {x: \"Petal.Length\", fy: \"Petal.Width\"})\n  ]\n})\n\n\n\n\n\n\n\n\n\n\n\n\nMap\nProjections for maps by their very nature tranform the coordinate system, so let’s see how we can use them in Plot.js.\n\nRPlot.js\n\n\nSomething is a weird about the y-axis here, but we’ll ignore it\nData: states\nLayer: geom_sf()\nCoordinates: coord_sf(crs = st_crs(\"ESRI:102003\"))\n\n\n\nR\n\nlibrary(sf)\n\nstates &lt;- read_sf(\"https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json\")\nst_crs(states) &lt;- 4326\n\nggplot(states) +\n    geom_sf() +\n    coord_sf(crs = st_crs(\"ESRI:102003\"))\n\n\n\n\n\n\n\n\n\n\n\nWe have to read in our data using d3 and topojson.\nData: statemesh\nLayer: Plot.geo()\nCoordinates: projection: \"albers-usa\"\n\n\n\nojs\n\nd3 = require(\"d3@7\")\ntopojson = require(\"topojson\")\n\nus_states = d3.json(\"https://cdn.jsdelivr.net/npm/us-atlas@3/states-10m.json\")\nstatemesh = topojson.mesh(states, states.objects.states)\n\nPlot.plot({\n  projection: \"albers-usa\",\n  marks: [\n    Plot.geo(statemesh, {strokeOpacity: 1})\n  ]\n})"
  },
  {
    "objectID": "notes/ojs/index.html#no-even-bother-translating-to-d3",
    "href": "notes/ojs/index.html#no-even-bother-translating-to-d3",
    "title": "Observable JS for an ggplot2 user",
    "section": "No even bother translating to D3",
    "text": "No even bother translating to D3\nOkay, we’re going to delve into d3. You probably get the point of Plot.js. Fundamentally, your thought process when making a Plot.js chart is relatively the same with slightly different syntax. But if you want to use D3 you’re going to completely rethink the way you make visualizations.\n\nBasic scatterplot\n\nscatterplot = {\n\n  // Specify the chart’s dimensions.\n  const width = 928;\n  const height = 600\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  const data = transpose(iris);\n\n  // Define the horizontal scale.\n  const x = d3.scaleLinear()\n      .domain(d3.extent(data, d =&gt; d[\"Petal.Length\"])).nice()\n      .range([marginLeft, width - marginRight]);\n\n  // Define the vertical scale.\n  const y = d3.scaleLinear()\n      .domain(d3.extent(data, d =&gt; d[\"Petal.Width\"])).nice()\n      .range([height - marginBottom, marginTop]);\n\n  // Create the container SVG.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Add the axes.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x));\n\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y));\n\n  // Append a circle for each data point.\n  svg.append(\"g\")\n    .selectAll(\"circle\")\n    .data(data)\n    .join(\"circle\")\n      .filter(d =&gt; d[\"Petal.Width\"])\n      .attr(\"cx\", d =&gt; x(d[\"Petal.Length\"]))\n      .attr(\"cy\", d =&gt; y(d[\"Petal.Width\"]))\n      .attr(\"r\", 3);\n\n  return svg.node();\n}\n\n\n\n\n\n\n\n\nBasic barplot\n\nbarplot = {\n  // Declare the chart dimensions and margins.\n  const width = 928;\n  const height = 600\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  const data = transpose(iris_freq);\n\n  // Declare the x scale.\n  const x = d3.scaleBand()\n      .domain(d3.groupSort(data, ([d]) =&gt; -d.n, (d) =&gt; d.Species)) // descending frequency\n      .range([marginLeft, width - marginRight])\n      .padding(0.1);\n  \n  // Declare the y scale.\n  const y = d3.scaleLinear()\n      .domain([0, d3.max(data, (d) =&gt; d.n)])\n      .range([height - marginBottom, marginTop]);\n\n  // Declare the fill scale.\n  const fillScale = d3.scaleOrdinal()\n    .domain(data.map(d =&gt; d.Species))\n    .range([\"#1f77b4\", \"#ff7f0e\", \"#2ca02c\"]);\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto;\");\n\n  // Add a rect for each bar.\n  svg.append(\"g\")\n    .selectAll()\n    .data(data)\n    .join(\"rect\")\n      .attr(\"x\", (d) =&gt; x(d.Species))\n      .attr(\"y\", (d) =&gt; y(d.n))\n      .attr(\"height\", (d) =&gt; y(0) - y(d.n))\n      .attr(\"width\", x.bandwidth())\n      .attr(\"fill\", (d) =&gt; fillScale(d.Species));\n\n\n  // Add the x-axis and label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x).tickSizeOuter(0));\n\n  // Add the y-axis and label, and remove the domain line.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).tickFormat((y) =&gt; (y * 100).toFixed()))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"↑ n\"));\n\n  // Return the SVG element.\n  return svg.node();\n}\n\n\n\n\n\n\n\n\nTemporal log-scale line plot\n\nlineplot = {\n  // Declare the chart dimensions and margins.\n  const width = 928;\n  const height = 600\n  const marginTop = 20;\n  const marginRight = 20;\n  const marginBottom = 30;\n  const marginLeft = 40;\n\n  const data = transpose(economics);\n\n  // Declare the x (horizontal position) scale.\n  const x = d3.scaleUtc()\n      .domain(d3.extent(data, d =&gt; new Date(d.date)))\n      .range([marginLeft, width - marginRight]);\n\n  // Declare the y (vertical position) scale.\n  const y = d3.scaleLog()\n      .domain(d3.extent(data, d =&gt; d.unemploy))\n      .range([height - marginBottom, marginTop]);\n\n  // Declare the line generator.\n  const line = d3.line()\n      .x(d =&gt; x(new Date(d.date)))\n      .y(d =&gt; y(d.unemploy));\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"max-width: 100%; height: auto; height: intrinsic;\");\n\n  // Add the x-axis.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(0,${height - marginBottom})`)\n      .call(d3.axisBottom(x).ticks(width / 80).tickSizeOuter(0));\n\n  // Add the y-axis, remove the domain line, add grid lines and a label.\n  svg.append(\"g\")\n      .attr(\"transform\", `translate(${marginLeft},0)`)\n      .call(d3.axisLeft(y).ticks(height / 40))\n      .call(g =&gt; g.select(\".domain\").remove())\n      .call(g =&gt; g.selectAll(\".tick line\").clone()\n          .attr(\"x2\", width - marginLeft - marginRight)\n          .attr(\"stroke-opacity\", 0.1))\n      .call(g =&gt; g.append(\"text\")\n          .attr(\"x\", -marginLeft)\n          .attr(\"y\", 10)\n          .attr(\"fill\", \"currentColor\")\n          .attr(\"text-anchor\", \"start\")\n          .text(\"↑ Daily close ($)\"));\n\n  // Append a path for the line.\n  svg.append(\"path\")\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"steelblue\")\n      .attr(\"stroke-width\", 1.5)\n      .attr(\"d\", line(data));\n\n  return svg.node();\n}\n\n\n\n\n\n\n\n\nFaceted boxplot\nThis is a decent bit of work, you gotta bin the observations, calculate the IQR, range, and outliers, and create all the boxes, lines, and circles.\n\n\nMap\n\nus = d3.json(\"https://cdn.jsdelivr.net/npm/us-atlas@3/counties-albers-10m.json\")\n\nnation = topojson.feature(us, us.objects.nation)\nstates = topojson.mesh(us, us.objects.states)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nmap = {\n  // Declare the chart dimensions and margins.\n  const width = 975;\n  const height = 610;\n\n  // Construct a path generator.\n  const path = d3.geoPath();\n\n  // Create the SVG container.\n  const svg = d3.create(\"svg\")\n      .attr(\"width\", width)\n      .attr(\"height\", height)\n      .attr(\"viewBox\", [0, 0, width, height])\n      .attr(\"style\", \"width: 100%; height: auto; height: intrinsic;\");\n\n  // Create the cartographic background layers.\n  svg.append(\"path\")\n      .datum(nation)\n      .attr(\"fill\", \"#ddd\")\n      .attr(\"d\", path);\n\n  // Create state outlines.\n  svg.append(\"path\")\n      .datum(states)\n      .attr(\"fill\", \"none\")\n      .attr(\"stroke\", \"white\")\n      .attr(\"stroke-linejoin\", \"round\")\n      .attr(\"d\", path);\n\n  return svg.node();\n}"
  },
  {
    "objectID": "notes/ojs/index.html#cool-maps",
    "href": "notes/ojs/index.html#cool-maps",
    "title": "Observable JS for an ggplot2 user",
    "section": "Cool maps",
    "text": "Cool maps\n\nVector map\n\nelection = d3.csv(\"https://raw.githubusercontent.com/tonmcg/US_County_Level_Election_Results_08-20/refs/heads/master/2020_US_County_Level_Presidential_Results.csv\")\n\ncounties = {\n  const counties = topojson.feature(us, us.objects.counties).features;\n  const _election = new Map(election.map((d) =&gt; [d.fips, d]));\n  counties.forEach(county =&gt; {\n    county.properties.margin2020 = +_election.get(county.id)?.margin2020;\n    county.properties.votes = +_election.get(county.id)?.votes;\n  });\n  return counties;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPlot.plot({\n  projection: \"albers-usa\",\n  length: {type: \"sqrt\", transform: Math.abs},\n  marks: [\n    Plot.geo(states, {strokeWidth: 0.5}),\n    Plot.geo(nation),\n    Plot.vector(\n      counties,\n      Plot.centroid({\n        anchor: \"start\",\n        length: (d) =&gt; d.properties.margin2020 * d.properties.votes,\n        stroke: (d) =&gt; d.properties.margin2020 &gt; 0 ? \"red\" : \"blue\",\n        rotate: (d) =&gt; d.properties.margin2020 &gt; 0 ? 60 : -60\n      })\n    )\n  ]\n})"
  },
  {
    "objectID": "project/pa470/index.html",
    "href": "project/pa470/index.html",
    "title": "PA 470",
    "section": "",
    "text": "PA 470 - Artificial Intelligence and Machine Learning in the Public Sector is a course taught by Eric Langowski as a part of the Civic Analytics curriculum at UIC. In the course, we worked through building an machine learning model to predict the sale prices of Cook county single family homes.\nFor my final project, I decided to do a replication study of Estimated Childhood Lead Exposure From Drinking Water in Chicago (Huynh et al., 2024). In the process, I learned a ton about Chicago’s lead contaminated water issues (Did you know that lead service lines were MANDATED by the city of Chicago until 1986 and as a result Chicago has 400,000 lead service lines).\nThe modeling involved a ton of data cleaning to aggregate data from the City of Chicago Department of Water Management Lead Test data, US Decennial Census, American Community Survey, Chicago Data Portal, and Chicago Health Atlas. Unfortunately, predicting lead exposure at the block level for a city as big as Chicago is quite a big problem. In the end I limited my models to elastic net logistic regression and random forest and limited my area of interest to the West Side of Chicago. But it was definitely a cool project, and you can check out my work at the above website."
  },
  {
    "objectID": "project/healthatlas/index.html",
    "href": "project/healthatlas/index.html",
    "title": "healthatlas",
    "section": "",
    "text": "healthatlas is an unofficial R wrapper for Metopio atlases. Users can explore and download public health data straight from any atlas. This makes R workflows that rely on atlas data more painless and reproducable.\nI developed healthatlas in part as an exploration of httr2 functionality and to develop an easier way to download data from the Chicago Health Atlas (I find the website interface for downloading data a little inconvenient)."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Ryan Zomorrodi",
    "section": "",
    "text": "Hi, I'm \n\n  \n    \n      Ryan Zomorrodi\n      a Data Analyst\n      an OSS Enthusiast\n      an R Nerd\n     \n  \n\n\n  \n  \n  \n\n\n\nI’m an data analyst working for the Children’s Environmental Health Initiative and an MS in Health Analytics student at University of Illinois Chicago. I enjoy utilizing data to solve complex problems and making tools that make data analysis easier."
  },
  {
    "objectID": "index.html#latest-projects",
    "href": "index.html#latest-projects",
    "title": "Ryan Zomorrodi",
    "section": "Latest Projects",
    "text": "Latest Projects\n\n\n\n\n\n\n\n\n\n\nhealthatlas\n\n\nExplore and Import Metopio Powered Health Atlases\n\n\n\nSep 13, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncentr\n\n\nA Package for Weighted and Unweighted Spatial Centers\n\n\n\nJul 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRate Stabilizing Tool 2\n\n\nSmall Area Estimation ArcGIS Pro Python Toolbox\n\n\n\nJul 18, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project/index.html",
    "href": "project/index.html",
    "title": "Projects",
    "section": "",
    "text": "healthatlas\n\n\nExplore and Import Metopio Powered Health Atlases\n\n\n\nSep 13, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\ncentr\n\n\nA Package for Weighted and Unweighted Spatial Centers\n\n\n\nJul 21, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRate Stabilizing Tool 2\n\n\nSmall Area Estimation ArcGIS Pro Python Toolbox\n\n\n\nJul 18, 2024\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPA 470\n\n\nMachine Learning in the Public Sector\n\n\n\nApr 27, 2024\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "project/centr/index.html",
    "href": "project/centr/index.html",
    "title": "centr",
    "section": "",
    "text": "centr is a package designed to calculate population weighted mean or median spatial centers. Mean centers can be calculated for projected and lon lat geometries. centr assumes a spherical representation of the earth for lon lat geometries, similar to S2.\nPopulation weighted centroids are a powerful tool to calculate plausible population exposure measures, and I use them quite a bit in my work. Now with centr calculating population weighted centroids within R is easy and fast."
  },
  {
    "objectID": "project/rst/index.html",
    "href": "project/rst/index.html",
    "title": "Rate Stabilizing Tool 2",
    "section": "",
    "text": "The Rate Stabilizing Tool(box) 2 is an ArcGIS Pro python toolbox for generating reliable, local-level age-standardized measures of chronic disease developed from scratch in partnership with the Centers for Disease Control and Prevention to replace the original Rate Stabilizing Tool.\nIt composed of two tools:\n\nIndividual Data Processing Tool (IDP): Aggregates individual data to an optionally age stratified population table and preforms checks to warn user if input data is invalid.\nRate Stabilizing Tool (RST): Utilizes a restricted CAR model to generate optionally age adjusted rates for local areas given the population data from the IDP and a geographic layer.\n\nIt improves on the original RST by radically simplifying the interface, speeding up estimatation time, and providing better error/warning messaging."
  },
  {
    "objectID": "notes/index.html",
    "href": "notes/index.html",
    "title": "Notes",
    "section": "",
    "text": "Observable JS for an ggplot2 user\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  }
]